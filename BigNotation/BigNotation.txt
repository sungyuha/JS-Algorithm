빅오 
- 다양한 문제를 표기하고 컴퓨터 공학과 데이터 구조에 대한 것
- 코드를 분류하거나 비교 할 수 있는 시스템
- 어떤 펑션의 입력 값이 늘어나는 것과 펑션 실행 시간이 변하는 관계를 의미

* 어떤 코드가 더 빠르고, 메모리를 얼마나 사용하는지, 
만들어지는 변수의 갯수라든가 평선을 호출 할 때마다 저장되는 데이터, 코드를 얼마나 쉽게 읽을 수 있는지

=> 최대한 적은 코드를 작성하는 것을 좋아함

The Problem with Time
- 시간에 문제가 있음
- 기기마다 다른 방식으로 시간을 기록 (기기 사양에 따라서 다를 수 도 있어 완전히 믿을 수 없음)
- 기계에 무엇이 실행 되고 있는지에 따라 다름
- 차이가 달라질 수 있고, 책정 된 시간들이 달라질 수 있음
- 언제나 다른 시간이 기록 됨
- 똑같은 기계가 다른 시간을 기록함

연산 갯수 세기
- 코드가 실행 될 떄 걸리는 정확한 시간을 초로 측정하기 보다는 대신에 컴퓨터가 처리해야하는 연산 갯수를 세면 됨

빅오 표기법
- 정식으로 입력 된 내용이 늘어날 수록 알고리즘에 실행 시간이 어떻게 변하는지 설명하는 공식적인 방식

빅오 규칙 or 빅오 표현식의 단순화하기
- 상수는 중요하지 않음
    ex) O(2n)이 있다면 이걸 O(n)으로 단순하게 표기할 수 있음
- 작은 연산들도 중요하지 않음
    ex) O(n+10)에서 +10은 없애버리고 O(n)이 됨

빅오 표기법의 예제
1. O(1) : 스택에서 Push, Pop
2. O(log n) : 이진트리
3. O(n) : for 문
4. O(n log n) : 퀵 정렬(quick sort), 병합정렬(merge sort), 힙 정렬(heap Sort)
5. O(): 이중 for 문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort)
6. O() : 피보나치 수열

빅오의 규칙
1. 산수는 상수 (덧셈, 뺄셈, 곱셉, 나눗셈을 포함)
2. 변수 할당(배정)도 상수
3. index를 사용해서 배열 elements를 접근 -> 배열에서 첫 번째 아이템을 찾던지, 10번째 아이템을 찾던지 index를 사용하면 똑같은 시간이 걸림
아니면, 객체를 다루고 데이터를 접근하기 위해 key가 있다면 그것도 실행 시간이 상수
4. 루프가 있으면 복잡도가 루프의 길이 곱하기or루프안에 있는 연산들 -> 리스트에 있는 데이터를 루프로 처리할 때 0에서 n까지 간다면, n이 커질 수록 루프가 반복되는 횟수가 늘어남
(중첩 루프가 있다면 n제곱 시간이 됨)
